#include "threadsafe.h"
#include "pingpong.h"
#include "singleton.h"
#include "syncstream.h"

int main() {

//--------------------------------------------------------------------------------------------
//		ЗАДАНИЕ 1
//--------------------------------------------------------------------------------------------
/*
Потокобезопасный стек. std::mutex. std::lock_guard. std::shared_mutex. std::lock(). std::scoped_lock.
Разработаем класс threadsafe_stack:
1.	чтобы не тратить время на рутинную работу, в качестве хранилища данных используем std::vector
2.	Для того чтобы предотвратить состояние гонки при добавлении/изъятии данных из стека, следует:
	на время модификации защитить всю структуру данных целиком от возможности доступа к данным 
	одновременно из двух и более потоков => должен быть общий мьютекс, который может использовать 
	любой поток, обращающийся к стеку => делаем мьютекс членом класса threadsafe_stack, так как мы
	будем использовать мьютекс в константных методах, нужно позволить вызывать его неконстантные 
	методы =>???
3.	все методы на время чтения/записи должны защищать свои операции мьютексом
4.	Подсказка: метод push() не может (не должен) принимать в качестве параметра ссылку, так как
	другой поток может изменить значение по адресу
5.	Проблема: разработчики std::vector разделили две операции: получение значения последнего 
	элемента  - T& back();  и удаление последнего элемента – void pop_back(); 
	Если бы метод был реализован: T pop_back (); (объединение двух операций) и в 
	процессе формирования возвращаемого значения (при копировании) генерируется исключение, 
	то возникает ситуация, когда из стека данные уже удалены, а возвращаемое значение еще 
	не сформировано => данные потеряны!Но! для потокобезопасного стека такое разделение операций 
	порождает гонку: мьютекс не «спасает» в ситуации (то есть возникает гонка):
	if(!s.empty())
	{
	res = s.top();
	s.pop();
	do_smth(res);
	},
	так как между вызовом empty() и top() другой поток может вызвать pop()аналогично гонка может возникнуть между вызовом top() и pop()
_________________________________________
|	Поток 1		   |	 Поток 2		|
-----------------------------------------
|if(!s.empty())    |					|
|{				   |	                |
|res = s.top();	   |					|
|				   |if(!s.empty())		|
|				   |{				    |
|				   |res = s.top();      |
|				   |s.pop();			|
|				   |do_smth(res);		|
|				   |}					|
|s.pop();		   |					|
|do_smth(res);     |					|
|}				   |				    |
-----------------------------------------
одно значение прочитано вообще не будет, а другое будет обработано дважды!Решение – попробовать безопасно совместить эти две операции 
(можно реализовать оба приведенных ниже варианта, чтобы у пользователя был выбор):
Вариант 1: void pop(T& val); //клиент предоставляет адрес для «выталкиваемого» из стека значения => если при копировании генерируется 
исключение, то оригинал остается в стеке.
Вариант 2: возвращать указатель на динамическую копию выталкиваемого элемента. Затратно, 
но безопасно, так как при копировании указателей не может быть сгенерировано исключение. Остается проблема управления динамической 
памятью, которую можно решить посредством std::shared_ptr<T> - std::shared_ptr<T> pop();
Вариант 3: optional<T> pop();
6.	При реализации конструктора копирования нужно защитить от модификаций только источник
7.	При реализации operator= нужно учесть возможность взаимных блокировок => нужно защитить как источник, так и приемник.
8.	Запустите несколько потоков, которые будут формировать значения в стеке – push() (поставщики) с заданным  периодом и один поток, который будет с заданным периодом доставать элемент с верхушки и обрабатывать
9.	При попытке достать элемент с верхушки ПУСТОГО стека
o	или должно быть сгенерировано исключение. Но! исключение сгенерировано в дочернем потоке, а обработать логично в родительском потоке
o	или возвращен «пустой» optional
*/
	{
		extern std::atomic<bool>stopConsumer;
		threadsafe_stack<int>stack;

		//Потоки производителей
		std::thread producer1(producer, std::ref(stack), 0, 10, 100);
		std::thread producer2(producer, std::ref(stack), 100, 10, 150);

		//Поток потребителя
		std::thread consumer_thread(consumer, std::ref(stack), 200);

		// Ждем немного и останавливаем поток
		std::this_thread::sleep_for(std::chrono::seconds(5));
		// Сигнал остановки
		stopConsumer = true; 

		producer1.join();
		producer2.join();
		consumer_thread.join();
	}
//--------------------------------------------------------------------------------------------
//		ЗАДАНИЕ 2
//--------------------------------------------------------------------------------------------
/*
Пинг - понг на семафорах.semaphore, jthread
Пусть два потока играют в пинг - понг.Игру может остановить только судья(нажатием любой клавиши).Реализуем 
простейший случай, когда игроков всего двое(а мячик один).Правило очень простое : чтобы отбить удар(pong), 
нужно, чтобы другой этот удар сделал(ping).И по правилам всегда есть тот, кто начинает первым(ping).Тот, 
кто бьет, выводит “ping”, тот, кто отбивает - “pong”.
Подсказка 1– для организации взаимодействия достаточно использовать двоичные семафоры;
Подсказка 2: подумайте, как следует инициализировать семафоры ?
*/
	{
		std::cout << "Press any key to stop game..." << std::endl;
		//Создаем потоки
		std::jthread pingThread(playPing);
		std::jthread pongThread(playPong);

		
		//Ожидание нажатия клавиши
		std::cin.get();
		//Сигнал всем потокам завершиться
		extern std::atomic<bool> stopGame;
		stopGame = true;

		extern std::binary_semaphore pingSemaphore;
		extern std::binary_semaphore pongSemaphore;
		//Завершение потоков
		//Освобождаем поток, если он ожидает
		pingSemaphore.release();
		//Освобождаем поток, если он ожидает
		pongSemaphore.release();
	}
//--------------------------------------------------------------------------------------------
//		ЗАДАНИЕ 3
//--------------------------------------------------------------------------------------------
/*
Thread-safe Singletonthread_local
Создайте класс, реализующий паттерн проектирования Синглтон.
Какие операции с таким объектом нужно запретить? и как?

1 вариант - один объект в рамках многопоточного приложения
2 вариант – для каждого потока один экземпляр
*/
	{
	//Один объект для всего приложения
		std::thread t1(useSingleton);
		std::thread t2(useSingleton);
		t1.join();
		t2.join();

		//Один объект на поток
		std::thread t3(useThreadLocalSingleton);
		std::thread t4(useThreadLocalSingleton);
		t3.join();
		t4.join();
	}
//--------------------------------------------------------------------------------------------
//		ЗАДАНИЕ 4
//--------------------------------------------------------------------------------------------
/*
Thread_local, osyncstream. Исследуем реализацию thread_local – переменных.
Дано:thread_local std::string s("hello from "); //вне всяких {} определяем строку
Запускаем потоки, в которые в качестве параметра передаем порядковый номер потока (порядок, в котором потоки были запущены). В потоковой функции модифицируем s следующим образом: добавляем (+=) номер запуска. Выводим результирующую строку и адрес s. Наблюдаем результат, если результат не очень нравится, вспоминаем про osyncstream.
*/
	{
		extern std::string s;

		const int numThreads = 5;

		//Запускаем несколько потоков
		std::thread threads[numThreads];
		for (size_t i = 0; i < numThreads; i++)
		{
			threads[i] = std::thread(threadFunction,i);
		}
		//Ждем завершения всех потоков
		for(auto& t:threads) {
			t.join();
		}
	}
	return 0;
}